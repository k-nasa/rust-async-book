# ランタイムを読んで理解しよう

では、ついに実際の非同期ランタイムのコードを**なるべく隅から隅まで**解説していこうと思います。

今回読んでいくコードは`async-std`という Rust の非同期処理用ランタイムライブラリです。このライブラリ(Rust ではクレートと呼ぶ)はランタイムだけではなく、Rust の標準ライブラリ(`std`)を非同期にしたものでもあります。`std`では同期的だった File IO などを非同期化した関数群を提供するのがこのクレートの目的でもあります。

本書ではランタイム部分しか触れませんが、一応これから読んでいくライブラリの紹介を雑におこうと思いました。

注意事項なのですが、今回読んでいくコードは`async-std`の master ブランチのものではなく、`new-scheduler`ブランチのものになります。このブランチはまだ取り込まれていないため、本書で触れていくコードが`async-std`で今後使われていくか分かりません。現状、PR が出ている状態で、コードレビューや議論が行われている最中となっています。

それでは実際にランタイムを読んでいきましょう！

## ランタイムがしていることって何だっけ？

ついさっき「読んでいきましょう！」と言っておいて申し訳ないですが、もう少し、お話をしましょう。

ランタイム、ランタイムと言っていますが、これは裏で何をしてくれているのでしょうか？ランタイムは普段、私達が書いているコードには登場しません。秘密裏に私達の書いたコードを並行、または並列に動作させてくれます。これによって私達は簡単に、そして安全により効率的なプログラムを書くことが出来ています。

この縁の下の力持ちが本書の主役ですが、今の所、紹介もなければ、登場すらしていません。これで主役と言えるのでしょうか？なので、これからは「ランタイムくん」にスポットライトを当てていきます。

## async-std を用いたコードを少し見ていこう

`async-std`を使って非同期コードを書いていくとどの様になるのでしょうか？

```rust
use async_std::task;

fn main() {
    let mut futures = vec![];

    for i in 0..100_000_ {
        // 非同期タスクを生成している
        let handle = task::spawn(async move{
            println!("{}", i);
        });

        futures.push(handle);
    }

    task::block_on(async {
        for f in futures {
            f.await
        }
    });
}
```
